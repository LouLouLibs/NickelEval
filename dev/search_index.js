var documenterSearchIndex = {"docs":
[{"location":"man/ffi/#FFI-Mode-(High-Performance)","page":"FFI Mode (High Performance)","title":"FFI Mode (High Performance)","text":"For repeated evaluations, NickelEval provides native FFI bindings to a Rust library that wraps nickel-lang-core. This eliminates subprocess overhead.","category":"section"},{"location":"man/ffi/#Checking-FFI-Availability","page":"FFI Mode (High Performance)","title":"Checking FFI Availability","text":"using NickelEval\n\ncheck_ffi_available()  # => true or false\n\nFFI is available when the compiled Rust library exists in the deps/ folder.","category":"section"},{"location":"man/ffi/#Using-FFI-Evaluation","page":"FFI Mode (High Performance)","title":"Using FFI Evaluation","text":"# Basic evaluation\nnickel_eval_ffi(\"1 + 2\")  # => 3\n\n# With dot-access\nconfig = nickel_eval_ffi(\"{ host = \\\"localhost\\\", port = 8080 }\")\nconfig.host  # => \"localhost\"\n\n# Typed evaluation\nnickel_eval_ffi(\"{ a = 1, b = 2 }\", Dict{String, Int})\n# => Dict{String, Int64}(\"a\" => 1, \"b\" => 2)","category":"section"},{"location":"man/ffi/#Building-the-FFI-Library","page":"FFI Mode (High Performance)","title":"Building the FFI Library","text":"","category":"section"},{"location":"man/ffi/#Requirements","page":"FFI Mode (High Performance)","title":"Requirements","text":"Rust toolchain (install from rustup.rs)\nCargo","category":"section"},{"location":"man/ffi/#Build-Steps","page":"FFI Mode (High Performance)","title":"Build Steps","text":"cd rust/nickel-jl\ncargo build --release\n\nThen copy the library to deps/:\n\n# macOS\ncp target/release/libnickel_jl.dylib ../../deps/\n\n# Linux\ncp target/release/libnickel_jl.so ../../deps/\n\n# Windows\ncp target/release/nickel_jl.dll ../../deps/","category":"section"},{"location":"man/ffi/#Performance-Comparison","page":"FFI Mode (High Performance)","title":"Performance Comparison","text":"FFI mode is faster for repeated evaluations because it:\n\nNo process spawn: Direct library calls instead of subprocess\nShared memory: Values transfer directly without serialization\nPersistent state: Library remains loaded\n\nFor single evaluations, the difference is minimal. For batch processing or interactive use, FFI mode is significantly faster.","category":"section"},{"location":"man/ffi/#Binary-Protocol","page":"FFI Mode (High Performance)","title":"Binary Protocol","text":"The FFI uses a binary protocol that preserves type information:\n\nType Tag Nickel Type\n0 Null\n1 Bool\n2 Int64\n3 Float64\n4 String\n5 Array\n6 Record\n\nThis allows direct conversion to Julia types without JSON parsing overhead.","category":"section"},{"location":"man/ffi/#Fallback-Behavior","page":"FFI Mode (High Performance)","title":"Fallback Behavior","text":"If FFI is not available, you can still use the subprocess-based functions:\n\n# Always works (uses CLI)\nnickel_eval(\"1 + 2\")\n\n# Requires FFI library\nnickel_eval_ffi(\"1 + 2\")  # Error if not built","category":"section"},{"location":"man/ffi/#Troubleshooting","page":"FFI Mode (High Performance)","title":"Troubleshooting","text":"","category":"section"},{"location":"man/ffi/#\"FFI-not-available\"-Error","page":"FFI Mode (High Performance)","title":"\"FFI not available\" Error","text":"Build the Rust library:\n\ncd rust/nickel-jl\ncargo build --release\ncp target/release/libnickel_jl.* ../../deps/","category":"section"},{"location":"man/ffi/#Library-Not-Found","page":"FFI Mode (High Performance)","title":"Library Not Found","text":"Ensure the library has the correct name for your platform:\n\nmacOS: libnickel_jl.dylib\nLinux: libnickel_jl.so\nWindows: nickel_jl.dll","category":"section"},{"location":"man/export/#Export-to-Config-Formats","page":"Export to Config Formats","title":"Export to Config Formats","text":"NickelEval can export Nickel code to JSON, TOML, or YAML strings for generating configuration files.","category":"section"},{"location":"man/export/#JSON-Export","page":"Export to Config Formats","title":"JSON Export","text":"nickel_to_json(\"{ name = \\\"myapp\\\", port = 8080 }\")\n\nOutput:\n\n{\n  \"name\": \"myapp\",\n  \"port\": 8080\n}","category":"section"},{"location":"man/export/#TOML-Export","page":"Export to Config Formats","title":"TOML Export","text":"nickel_to_toml(\"{ name = \\\"myapp\\\", port = 8080 }\")\n\nOutput:\n\nname = \"myapp\"\nport = 8080","category":"section"},{"location":"man/export/#YAML-Export","page":"Export to Config Formats","title":"YAML Export","text":"nickel_to_yaml(\"{ name = \\\"myapp\\\", port = 8080 }\")\n\nOutput:\n\nname: myapp\nport: 8080","category":"section"},{"location":"man/export/#Generic-Export-Function","page":"Export to Config Formats","title":"Generic Export Function","text":"Use nickel_export with the format keyword:\n\nnickel_export(\"{ a = 1 }\"; format=:json)\nnickel_export(\"{ a = 1 }\"; format=:toml)\nnickel_export(\"{ a = 1 }\"; format=:yaml)","category":"section"},{"location":"man/export/#Generating-Config-Files","page":"Export to Config Formats","title":"Generating Config Files","text":"","category":"section"},{"location":"man/export/#Example:-Generate-Multiple-Formats","page":"Export to Config Formats","title":"Example: Generate Multiple Formats","text":"config = \"\"\"\n{\n  database = {\n    host = \"localhost\",\n    port = 5432,\n    name = \"mydb\"\n  },\n  server = {\n    host = \"0.0.0.0\",\n    port = 8080\n  },\n  logging = {\n    level = \"info\",\n    file = \"/var/log/app.log\"\n  }\n}\n\"\"\"\n\n# Generate TOML config\nwrite(\"config.toml\", nickel_to_toml(config))\n\n# Generate YAML config\nwrite(\"config.yaml\", nickel_to_yaml(config))\n\n# Generate JSON config\nwrite(\"config.json\", nickel_to_json(config))","category":"section"},{"location":"man/export/#Example:-Environment-Specific-Configs","page":"Export to Config Formats","title":"Example: Environment-Specific Configs","text":"base_config = \"\"\"\n{\n  app_name = \"myapp\",\n  log_level = \"info\"\n}\n\"\"\"\n\ndev_overrides = \"\"\"\n{\n  debug = true,\n  database = { host = \"localhost\" }\n}\n\"\"\"\n\nprod_overrides = \"\"\"\n{\n  debug = false,\n  database = { host = \"db.production.com\" }\n}\n\"\"\"\n\n# Merge and export\ndev_config = nickel_export(\"$base_config & $dev_overrides\"; format=:toml)\nprod_config = nickel_export(\"$base_config & $prod_overrides\"; format=:toml)","category":"section"},{"location":"man/export/#Nested-Structures","page":"Export to Config Formats","title":"Nested Structures","text":"TOML handles nested records as sections:\n\nnickel_to_toml(\"\"\"\n{\n  server = {\n    host = \"0.0.0.0\",\n    port = 8080\n  }\n}\n\"\"\")\n\nOutput:\n\n[server]\nhost = \"0.0.0.0\"\nport = 8080","category":"section"},{"location":"lib/public/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"lib/public/#Evaluation-Functions","page":"Public API","title":"Evaluation Functions","text":"","category":"section"},{"location":"lib/public/#Export-Functions","page":"Public API","title":"Export Functions","text":"","category":"section"},{"location":"lib/public/#FFI-Functions","page":"Public API","title":"FFI Functions","text":"","category":"section"},{"location":"lib/public/#String-Macro","page":"Public API","title":"String Macro","text":"","category":"section"},{"location":"lib/public/#NickelEval.nickel_eval","page":"Public API","title":"NickelEval.nickel_eval","text":"nickel_eval(code::String) -> JSON.Object\n\nEvaluate Nickel code and return a Julia value.\n\nReturns a JSON.Object for records (supports dot-access), or native Julia types for primitives and arrays.\n\nArguments\n\ncode::String: Nickel code to evaluate\n\nReturns\n\nResult as Julia value (JSON.Object for records, Vector for arrays, etc.)\n\nExamples\n\njulia> nickel_eval(\"1 + 2\")\n3\n\njulia> result = nickel_eval(\"{ a = 1, b = 2 }\")\njulia> result.a  # dot-access supported\n1\n\njulia> nickel_eval(\"let x = 5 in x * 2\")\n10\n\n\n\n\n\nnickel_eval(code::String, ::Type{T}) -> T\n\nEvaluate Nickel code and parse the result directly into a specific Julia type.\n\nUses JSON.jl 1.0's native typed parsing. Works with:\n\nPrimitive types: Int, Float64, String, Bool\nTyped dictionaries: Dict{String, Int}, Dict{Symbol, Float64}\nTyped arrays: Vector{Int}, Vector{String}\nNamedTuples for quick typed record access\nCustom structs\n\nArguments\n\ncode::String: Nickel code to evaluate\nT::Type: Target Julia type\n\nReturns\n\nT: The evaluated result as the specified type\n\nExamples\n\njulia> nickel_eval(\"1 + 2\", Int)\n3\n\njulia> nickel_eval(\"{ a = 1, b = 2 }\", Dict{String, Int})\nDict{String, Int64}(\"a\" => 1, \"b\" => 2)\n\njulia> nickel_eval(\"[1, 2, 3]\", Vector{Int})\n[1, 2, 3]\n\njulia> nickel_eval(\"{ x = 1.5, y = 2.5 }\", @NamedTuple{x::Float64, y::Float64})\n(x = 1.5, y = 2.5)\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#NickelEval.nickel_eval_file","page":"Public API","title":"NickelEval.nickel_eval_file","text":"nickel_eval_file(path::String) -> JSON.Object\nnickel_eval_file(path::String, ::Type{T}) -> T\n\nEvaluate a Nickel file and return a Julia value.\n\nArguments\n\npath::String: Path to the Nickel file\nT::Type: (optional) Target Julia type for typed parsing\n\nReturns\n\nJSON.Object or T: The evaluated result as a Julia value\n\nThrows\n\nNickelError: If file doesn't exist or evaluation fails\n\nExamples\n\n# Untyped evaluation (returns JSON.Object with dot-access)\njulia> config = nickel_eval_file(\"config.ncl\")\njulia> config.port\n8080\n\n# Typed evaluation\njulia> nickel_eval_file(\"config.ncl\", @NamedTuple{port::Int, host::String})\n(port = 8080, host = \"localhost\")\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#NickelEval.nickel_read","page":"Public API","title":"NickelEval.nickel_read","text":"nickel_read(code::String, ::Type{T}) -> T\n\nAlias for nickel_eval(code, T). Evaluate Nickel code into a typed Julia value.\n\nExamples\n\njulia> nickel_read(\"{ port = 8080, host = \"localhost\" }\", @NamedTuple{port::Int, host::String})\n(port = 8080, host = \"localhost\")\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#NickelEval.find_nickel_executable","page":"Public API","title":"NickelEval.find_nickel_executable","text":"find_nickel_executable() -> String\n\nFind the Nickel executable in PATH.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#NickelEval.nickel_export","page":"Public API","title":"NickelEval.nickel_export","text":"nickel_export(code::String; format::Symbol=:json) -> String\n\nExport Nickel code to the specified format string.\n\nArguments\n\ncode::String: Nickel code to evaluate\nformat::Symbol: Output format, one of :json, :yaml, :toml (default: :json)\n\nReturns\n\nString: The exported content in the specified format\n\nThrows\n\nNickelError: If evaluation fails or format is unsupported\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#NickelEval.nickel_to_json","page":"Public API","title":"NickelEval.nickel_to_json","text":"nickel_to_json(code::String) -> String\n\nExport Nickel code to JSON string.\n\nExamples\n\njulia> nickel_to_json(\"{ a = 1, b = 2 }\")\n\"{\\n  \\\"a\\\": 1,\\n  \\\"b\\\": 2\\n}\"\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#NickelEval.nickel_to_toml","page":"Public API","title":"NickelEval.nickel_to_toml","text":"nickel_to_toml(code::String) -> String\n\nExport Nickel code to TOML string.\n\nExamples\n\njulia> nickel_to_toml(\"{ name = \"myapp\", port = 8080 }\")\n\"name = \\\"myapp\\\"\\nport = 8080\\n\"\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#NickelEval.nickel_to_yaml","page":"Public API","title":"NickelEval.nickel_to_yaml","text":"nickel_to_yaml(code::String) -> String\n\nExport Nickel code to YAML string.\n\nExamples\n\njulia> nickel_to_yaml(\"{ name = \"myapp\", port = 8080 }\")\n\"name: myapp\\nport: 8080\\n\"\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#NickelEval.check_ffi_available","page":"Public API","title":"NickelEval.check_ffi_available","text":"check_ffi_available() -> Bool\n\nCheck if FFI bindings are available. Returns true if the native library is compiled and available.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#NickelEval.nickel_eval_ffi","page":"Public API","title":"NickelEval.nickel_eval_ffi","text":"nickel_eval_ffi(code::String) -> JSON.Object\nnickel_eval_ffi(code::String, ::Type{T}) -> T\n\nEvaluate Nickel code using native FFI bindings (faster than subprocess). Returns the parsed JSON result, optionally typed.\n\nThrows NickelError if FFI is not available or if evaluation fails.\n\nExamples\n\njulia> nickel_eval_ffi(\"1 + 2\")\n3\n\njulia> result = nickel_eval_ffi(\"{ x = 1, y = 2 }\")\njulia> result.x  # dot-access supported\n1\n\njulia> nickel_eval_ffi(\"{ x = 1, y = 2 }\", Dict{String, Int})\nDict{String, Int64}(\"x\" => 1, \"y\" => 2)\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#NickelEval.@ncl_str","page":"Public API","title":"NickelEval.@ncl_str","text":"@ncl_str -> Any\n\nString macro for inline Nickel evaluation.\n\nExamples\n\njulia> ncl\"1 + 2\"\n3\n\njulia> ncl\"{ name = \"test\", value = 42 }\".name\n\"test\"\n\njulia> ncl\"\"\"\n       let\n         x = 1,\n         y = 2\n       in x + y\n       \"\"\"\n3\n\n\n\n\n\n","category":"macro"},{"location":"#NickelEval.jl","page":"Home","title":"NickelEval.jl","text":"Julia bindings for the Nickel configuration language.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Evaluate Nickel code directly from Julia\nNative type conversion to Julia types (Dict, NamedTuple, custom structs)\nExport to multiple formats (JSON, TOML, YAML)\nHigh-performance FFI mode using Rust bindings\nDot-access for configuration records via JSON.Object","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#From-LouLouLibs-Registry-(Recommended)","page":"Home","title":"From LouLouLibs Registry (Recommended)","text":"using Pkg\nPkg.Registry.add(url=\"https://github.com/LouLouLibs/loulouJL\")\nPkg.add(\"NickelEval\")","category":"section"},{"location":"#From-GitHub-URL","page":"Home","title":"From GitHub URL","text":"using Pkg\nPkg.add(url=\"https://github.com/LouLouLibs/NickelEval\")\n\nPrerequisite: Install the Nickel CLI from nickel-lang.org","category":"section"},{"location":"#Quick-Example","page":"Home","title":"Quick Example","text":"using NickelEval\n\n# Simple evaluation\nnickel_eval(\"1 + 2\")  # => 3\n\n# Records with dot-access\nconfig = nickel_eval(\"{ host = \\\"localhost\\\", port = 8080 }\")\nconfig.host  # => \"localhost\"\nconfig.port  # => 8080\n\n# Typed evaluation\nnickel_eval(\"{ x = 1, y = 2 }\", Dict{String, Int})\n# => Dict{String, Int64}(\"x\" => 1, \"y\" => 2)\n\n# Export to TOML\nnickel_to_toml(\"{ name = \\\"myapp\\\", version = \\\"1.0\\\" }\")\n# => \"name = \\\"myapp\\\"\\nversion = \\\"1.0\\\"\\n\"","category":"section"},{"location":"#Why-Nickel?","page":"Home","title":"Why Nickel?","text":"Nickel is a configuration language designed to be:\n\nProgrammable: Functions, let bindings, and standard library\nTyped: Optional contracts for validation\nMergeable: Combine configurations with &\nSafe: No side effects, pure functional\n\nNickelEval.jl lets you leverage Nickel's power directly in your Julia workflows.","category":"section"},{"location":"#Contents","page":"Home","title":"Contents","text":"Pages = [\"man/quickstart.md\", \"man/typed.md\", \"man/export.md\", \"man/ffi.md\", \"lib/public.md\"]\nDepth = 2","category":"section"},{"location":"man/typed/#Typed-Evaluation","page":"Typed Evaluation","title":"Typed Evaluation","text":"NickelEval supports converting Nickel values directly to typed Julia values using JSON.jl 1.0's native typed parsing.","category":"section"},{"location":"man/typed/#Basic-Types","page":"Typed Evaluation","title":"Basic Types","text":"nickel_eval(\"42\", Int)        # => 42\nnickel_eval(\"3.14\", Float64)  # => 3.14\nnickel_eval(\"\\\"hi\\\"\", String) # => \"hi\"\nnickel_eval(\"true\", Bool)     # => true","category":"section"},{"location":"man/typed/#Typed-Dictionaries","page":"Typed Evaluation","title":"Typed Dictionaries","text":"","category":"section"},{"location":"man/typed/#String-Keys","page":"Typed Evaluation","title":"String Keys","text":"result = nickel_eval(\"{ a = 1, b = 2 }\", Dict{String, Int})\n# => Dict{String, Int64}(\"a\" => 1, \"b\" => 2)\n\nresult[\"a\"]  # => 1","category":"section"},{"location":"man/typed/#Symbol-Keys","page":"Typed Evaluation","title":"Symbol Keys","text":"result = nickel_eval(\"{ x = 1.5, y = 2.5 }\", Dict{Symbol, Float64})\n# => Dict{Symbol, Float64}(:x => 1.5, :y => 2.5)\n\nresult[:x]  # => 1.5","category":"section"},{"location":"man/typed/#Typed-Arrays","page":"Typed Evaluation","title":"Typed Arrays","text":"nickel_eval(\"[1, 2, 3]\", Vector{Int})\n# => [1, 2, 3]\n\nnickel_eval(\"[\\\"a\\\", \\\"b\\\", \\\"c\\\"]\", Vector{String})\n# => [\"a\", \"b\", \"c\"]","category":"section"},{"location":"man/typed/#NamedTuples","page":"Typed Evaluation","title":"NamedTuples","text":"For structured configuration access:\n\nconfig = nickel_eval(\"\"\"\n{\n  host = \"localhost\",\n  port = 8080,\n  debug = true\n}\n\"\"\", @NamedTuple{host::String, port::Int, debug::Bool})\n\n# => (host = \"localhost\", port = 8080, debug = true)\n\nconfig.host   # => \"localhost\"\nconfig.port   # => 8080\nconfig.debug  # => true","category":"section"},{"location":"man/typed/#Custom-Structs","page":"Typed Evaluation","title":"Custom Structs","text":"Define your own types:\n\nstruct ServerConfig\n    host::String\n    port::Int\n    workers::Int\nend\n\nconfig = nickel_eval(\"\"\"\n{\n  host = \"0.0.0.0\",\n  port = 3000,\n  workers = 4\n}\n\"\"\", ServerConfig)\n\n# => ServerConfig(\"0.0.0.0\", 3000, 4)","category":"section"},{"location":"man/typed/#File-Evaluation-with-Types","page":"Typed Evaluation","title":"File Evaluation with Types","text":"# config.ncl:\n# { environment = \"production\", max_connections = 100 }\n\nConfig = @NamedTuple{environment::String, max_connections::Int}\nconfig = nickel_eval_file(\"config.ncl\", Config)\n\nconfig.environment      # => \"production\"\nconfig.max_connections  # => 100","category":"section"},{"location":"man/typed/#The-nickel_read-Alias","page":"Typed Evaluation","title":"The nickel_read Alias","text":"nickel_read is an alias for typed nickel_eval:\n\nnickel_read(\"{ a = 1 }\", Dict{String, Int})\n# equivalent to\nnickel_eval(\"{ a = 1 }\", Dict{String, Int})","category":"section"},{"location":"man/quickstart/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"man/quickstart/#Installation","page":"Quick Start","title":"Installation","text":"","category":"section"},{"location":"man/quickstart/#From-LouLouLibs-Registry-(Recommended)","page":"Quick Start","title":"From LouLouLibs Registry (Recommended)","text":"using Pkg\nPkg.Registry.add(url=\"https://github.com/LouLouLibs/loulouJL\")\nPkg.add(\"NickelEval\")","category":"section"},{"location":"man/quickstart/#From-GitHub-URL","page":"Quick Start","title":"From GitHub URL","text":"using Pkg\nPkg.add(url=\"https://github.com/LouLouLibs/NickelEval\")\n\nMake sure you have the Nickel CLI installed:\n\nmacOS: brew install nickel\nOther: See nickel-lang.org","category":"section"},{"location":"man/quickstart/#Basic-Usage","page":"Quick Start","title":"Basic Usage","text":"using NickelEval\n\n# Evaluate simple expressions\nnickel_eval(\"1 + 2\")      # => 3\nnickel_eval(\"true\")       # => true\nnickel_eval(\"\\\"hello\\\"\")  # => \"hello\"","category":"section"},{"location":"man/quickstart/#Working-with-Records","page":"Quick Start","title":"Working with Records","text":"Nickel records become JSON.Object with dot-access:\n\nconfig = nickel_eval(\"\"\"\n{\n  database = {\n    host = \"localhost\",\n    port = 5432\n  },\n  debug = true\n}\n\"\"\")\n\nconfig.database.host  # => \"localhost\"\nconfig.database.port  # => 5432\nconfig.debug          # => true","category":"section"},{"location":"man/quickstart/#Let-Bindings-and-Functions","page":"Quick Start","title":"Let Bindings and Functions","text":"# Let bindings\nnickel_eval(\"let x = 10 in x * 2\")  # => 20\n\n# Functions\nnickel_eval(\"\"\"\nlet double = fun x => x * 2 in\ndouble 21\n\"\"\")  # => 42","category":"section"},{"location":"man/quickstart/#Arrays","page":"Quick Start","title":"Arrays","text":"nickel_eval(\"[1, 2, 3]\")  # => [1, 2, 3]\n\n# Array operations with std library\nnickel_eval(\"[1, 2, 3] |> std.array.map (fun x => x * 2)\")\n# => [2, 4, 6]","category":"section"},{"location":"man/quickstart/#Record-Merge","page":"Quick Start","title":"Record Merge","text":"nickel_eval(\"{ a = 1 } & { b = 2 }\")\n# => JSON.Object with a=1, b=2","category":"section"},{"location":"man/quickstart/#String-Macro","page":"Quick Start","title":"String Macro","text":"For inline Nickel code:\n\nncl\"1 + 1\"  # => 2\n\nconfig = ncl\"{ host = \\\"localhost\\\" }\"\nconfig.host  # => \"localhost\"","category":"section"},{"location":"man/quickstart/#File-Evaluation","page":"Quick Start","title":"File Evaluation","text":"# Evaluate a .ncl file\nconfig = nickel_eval_file(\"config.ncl\")","category":"section"},{"location":"man/quickstart/#Error-Handling","page":"Quick Start","title":"Error Handling","text":"try\n    nickel_eval(\"{ x = }\")  # syntax error\ncatch e\n    if e isa NickelError\n        println(\"Error: \", e.message)\n    end\nend","category":"section"}]
}
